// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATUS_STATUS_H_
#define FLATBUFFERS_GENERATED_STATUS_STATUS_H_

#include "flatbuffers/flatbuffers.h"

namespace Status {

struct Core;
struct CoreBuilder;

struct Module;
struct ModuleBuilder;

struct JNIMethod;
struct JNIMethodBuilder;

struct FbStatus;
struct FbStatusBuilder;

struct Core FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CoreBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_API = 4,
    VT_VERSION = 6,
    VT_VERSION_NAME = 8,
    VT_HIDE = 10
  };
  uint8_t api() const {
    return GetField<uint8_t>(VT_API, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *version_name() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION_NAME);
  }
  bool hide() const {
    return GetField<uint8_t>(VT_HIDE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_API) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_VERSION_NAME) &&
           verifier.VerifyString(version_name()) &&
           VerifyField<uint8_t>(verifier, VT_HIDE) &&
           verifier.EndTable();
  }
};

struct CoreBuilder {
  typedef Core Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_api(uint8_t api) {
    fbb_.AddElement<uint8_t>(Core::VT_API, api, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Core::VT_VERSION, version, 0);
  }
  void add_version_name(flatbuffers::Offset<flatbuffers::String> version_name) {
    fbb_.AddOffset(Core::VT_VERSION_NAME, version_name);
  }
  void add_hide(bool hide) {
    fbb_.AddElement<uint8_t>(Core::VT_HIDE, static_cast<uint8_t>(hide), 0);
  }
  explicit CoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CoreBuilder &operator=(const CoreBuilder &);
  flatbuffers::Offset<Core> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Core>(end);
    fbb_.Required(o, Core::VT_VERSION_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Core> CreateCore(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t api = 0,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> version_name = 0,
    bool hide = false) {
  CoreBuilder builder_(_fbb);
  builder_.add_version_name(version_name);
  builder_.add_version(version);
  builder_.add_hide(hide);
  builder_.add_api(api);
  return builder_.Finish();
}

inline flatbuffers::Offset<Core> CreateCoreDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t api = 0,
    uint32_t version = 0,
    const char *version_name = nullptr,
    bool hide = false) {
  auto version_name__ = version_name ? _fbb.CreateString(version_name) : 0;
  return Status::CreateCore(
      _fbb,
      api,
      version,
      version_name__,
      hide);
}

struct Module FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_API = 6,
    VT_VERSION = 8,
    VT_VERSION_NAME = 10,
    VT_HIDE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t api() const {
    return GetField<uint8_t>(VT_API, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *version_name() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION_NAME);
  }
  bool hide() const {
    return GetField<uint8_t>(VT_HIDE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_API) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_VERSION_NAME) &&
           verifier.VerifyString(version_name()) &&
           VerifyField<uint8_t>(verifier, VT_HIDE) &&
           verifier.EndTable();
  }
};

struct ModuleBuilder {
  typedef Module Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Module::VT_NAME, name);
  }
  void add_api(uint8_t api) {
    fbb_.AddElement<uint8_t>(Module::VT_API, api, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Module::VT_VERSION, version, 0);
  }
  void add_version_name(flatbuffers::Offset<flatbuffers::String> version_name) {
    fbb_.AddOffset(Module::VT_VERSION_NAME, version_name);
  }
  void add_hide(bool hide) {
    fbb_.AddElement<uint8_t>(Module::VT_HIDE, static_cast<uint8_t>(hide), 0);
  }
  explicit ModuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModuleBuilder &operator=(const ModuleBuilder &);
  flatbuffers::Offset<Module> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Module>(end);
    fbb_.Required(o, Module::VT_NAME);
    fbb_.Required(o, Module::VT_VERSION_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Module> CreateModule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t api = 0,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> version_name = 0,
    bool hide = false) {
  ModuleBuilder builder_(_fbb);
  builder_.add_version_name(version_name);
  builder_.add_version(version);
  builder_.add_name(name);
  builder_.add_hide(hide);
  builder_.add_api(api);
  return builder_.Finish();
}

inline flatbuffers::Offset<Module> CreateModuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t api = 0,
    uint32_t version = 0,
    const char *version_name = nullptr,
    bool hide = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto version_name__ = version_name ? _fbb.CreateString(version_name) : 0;
  return Status::CreateModule(
      _fbb,
      name__,
      api,
      version,
      version_name__,
      hide);
}

struct JNIMethod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JNIMethodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_REPLACED = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  bool replaced() const {
    return GetField<uint8_t>(VT_REPLACED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyField<uint8_t>(verifier, VT_REPLACED) &&
           verifier.EndTable();
  }
};

struct JNIMethodBuilder {
  typedef JNIMethod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(JNIMethod::VT_NAME, name);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(JNIMethod::VT_SIGNATURE, signature);
  }
  void add_replaced(bool replaced) {
    fbb_.AddElement<uint8_t>(JNIMethod::VT_REPLACED, static_cast<uint8_t>(replaced), 0);
  }
  explicit JNIMethodBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JNIMethodBuilder &operator=(const JNIMethodBuilder &);
  flatbuffers::Offset<JNIMethod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JNIMethod>(end);
    fbb_.Required(o, JNIMethod::VT_NAME);
    fbb_.Required(o, JNIMethod::VT_SIGNATURE);
    return o;
  }
};

inline flatbuffers::Offset<JNIMethod> CreateJNIMethod(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0,
    bool replaced = false) {
  JNIMethodBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_replaced(replaced);
  return builder_.Finish();
}

inline flatbuffers::Offset<JNIMethod> CreateJNIMethodDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    bool replaced = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  return Status::CreateJNIMethod(
      _fbb,
      name__,
      signature__,
      replaced);
}

struct FbStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FbStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_64BIT = 4,
    VT_CORE = 6,
    VT_MODULES = 8,
    VT_JNI_METHODS = 10
  };
  bool is_64bit() const {
    return GetField<uint8_t>(VT_IS_64BIT, 0) != 0;
  }
  const Status::Core *core() const {
    return GetPointer<const Status::Core *>(VT_CORE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Status::Module>> *modules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Status::Module>> *>(VT_MODULES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Status::JNIMethod>> *jni_methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Status::JNIMethod>> *>(VT_JNI_METHODS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_64BIT) &&
           VerifyOffset(verifier, VT_CORE) &&
           verifier.VerifyTable(core()) &&
           VerifyOffset(verifier, VT_MODULES) &&
           verifier.VerifyVector(modules()) &&
           verifier.VerifyVectorOfTables(modules()) &&
           VerifyOffset(verifier, VT_JNI_METHODS) &&
           verifier.VerifyVector(jni_methods()) &&
           verifier.VerifyVectorOfTables(jni_methods()) &&
           verifier.EndTable();
  }
};

struct FbStatusBuilder {
  typedef FbStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_64bit(bool is_64bit) {
    fbb_.AddElement<uint8_t>(FbStatus::VT_IS_64BIT, static_cast<uint8_t>(is_64bit), 0);
  }
  void add_core(flatbuffers::Offset<Status::Core> core) {
    fbb_.AddOffset(FbStatus::VT_CORE, core);
  }
  void add_modules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Status::Module>>> modules) {
    fbb_.AddOffset(FbStatus::VT_MODULES, modules);
  }
  void add_jni_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Status::JNIMethod>>> jni_methods) {
    fbb_.AddOffset(FbStatus::VT_JNI_METHODS, jni_methods);
  }
  explicit FbStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FbStatusBuilder &operator=(const FbStatusBuilder &);
  flatbuffers::Offset<FbStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FbStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<FbStatus> CreateFbStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_64bit = false,
    flatbuffers::Offset<Status::Core> core = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Status::Module>>> modules = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Status::JNIMethod>>> jni_methods = 0) {
  FbStatusBuilder builder_(_fbb);
  builder_.add_jni_methods(jni_methods);
  builder_.add_modules(modules);
  builder_.add_core(core);
  builder_.add_is_64bit(is_64bit);
  return builder_.Finish();
}

inline flatbuffers::Offset<FbStatus> CreateFbStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_64bit = false,
    flatbuffers::Offset<Status::Core> core = 0,
    const std::vector<flatbuffers::Offset<Status::Module>> *modules = nullptr,
    const std::vector<flatbuffers::Offset<Status::JNIMethod>> *jni_methods = nullptr) {
  auto modules__ = modules ? _fbb.CreateVector<flatbuffers::Offset<Status::Module>>(*modules) : 0;
  auto jni_methods__ = jni_methods ? _fbb.CreateVector<flatbuffers::Offset<Status::JNIMethod>>(*jni_methods) : 0;
  return Status::CreateFbStatus(
      _fbb,
      is_64bit,
      core,
      modules__,
      jni_methods__);
}

inline const Status::FbStatus *GetFbStatus(const void *buf) {
  return flatbuffers::GetRoot<Status::FbStatus>(buf);
}

inline const Status::FbStatus *GetSizePrefixedFbStatus(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Status::FbStatus>(buf);
}

inline bool VerifyFbStatusBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Status::FbStatus>(nullptr);
}

inline bool VerifySizePrefixedFbStatusBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Status::FbStatus>(nullptr);
}

inline void FinishFbStatusBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Status::FbStatus> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFbStatusBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Status::FbStatus> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Status

#endif  // FLATBUFFERS_GENERATED_STATUS_STATUS_H_
